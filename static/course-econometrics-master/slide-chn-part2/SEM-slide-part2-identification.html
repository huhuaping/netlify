<!DOCTYPE html>
<html lang="" xml:lang="">
  <head>
    <title>SEM-slide-part2-identification.knit</title>
    <meta charset="utf-8" />
    <script src="libs/header-attrs-2.11.2/header-attrs.js"></script>
    <link href="libs/remark-css-0.0.1/default.css" rel="stylesheet" />
    <link href="libs/remark-css-0.0.1/duke-blue.css" rel="stylesheet" />
    <link href="libs/remark-css-0.0.1/hygge-duke.css" rel="stylesheet" />
    <link href="libs/tachyons-4.12.0/tachyons.min.css" rel="stylesheet" />
    <link href="libs/panelset-0.2.4/panelset.css" rel="stylesheet" />
    <script src="libs/panelset-0.2.4/panelset.js"></script>
    <script src="libs/htmlwidgets-1.5.3/htmlwidgets.js"></script>
    <script src="libs/jquery-3.5.1/jquery.min.js"></script>
    <link href="libs/datatables-css-0.0.0/datatables-crosstalk.css" rel="stylesheet" />
    <script src="libs/datatables-binding-0.17/datatables.js"></script>
    <link href="libs/dt-core-1.10.20/css/jquery.dataTables.min.css" rel="stylesheet" />
    <link href="libs/dt-core-1.10.20/css/jquery.dataTables.extra.css" rel="stylesheet" />
    <script src="libs/dt-core-1.10.20/js/jquery.dataTables.min.js"></script>
    <link href="libs/crosstalk-1.1.1/css/crosstalk.css" rel="stylesheet" />
    <script src="libs/crosstalk-1.1.1/js/crosstalk.min.js"></script>
    <link rel="stylesheet" href="../mycss/my-theme.css" type="text/css" />
    <link rel="stylesheet" href="../mycss/my-font.css" type="text/css" />
    <link rel="stylesheet" href="../mycss/my-custom-for-video-roomy.css" type="text/css" />
    <link rel="stylesheet" href="../mycss/text-box.css" type="text/css" />
  </head>
  <body>
    <textarea id="source">

background-image: url("../pic/slide-front-page.jpg")
class: center,middle
count: false

# 计量经济学II
# (Econometrics II)

&lt;!---    chakra: libs/remark-latest.min.js ---&gt;


### 胡华平

### 西北农林科技大学

### 经济管理学院数量经济教研室

### huhuaping01@hotmail.com

### 2021-09-26





<div>
<style type="text/css">.xaringan-extra-logo {
width: 110px;
height: 70px;
z-index: 0;
background-image: url(../pic/logo/nwafu-logo-circle-wb.png);
background-size: contain;
background-repeat: no-repeat;
position: absolute;
top:0.2em;left:1em;
}
</style>
<script>(function () {
  let tries = 0
  function addLogo () {
    if (typeof slideshow === 'undefined') {
      tries += 1
      if (tries < 10) {
        setTimeout(addLogo, 100)
      }
    } else {
      document.querySelectorAll('.remark-slide-content:not(.title-slide):not(.inverse):not(.hide_logo)')
        .forEach(function (slide) {
          const logo = document.createElement('div')
          logo.classList = 'xaringan-extra-logo'
          logo.href = null
          slide.appendChild(logo)
        })
    }
  }
  document.addEventListener('DOMContentLoaded', addLogo)
})()</script>
</div>

---
layout: false
class: center, middle, duke-softblue,hide_logo
name: chapter-navi
count: true

# 模块4：联立方程模型（SEM）

.large[

[Chapter 18. 为什么要关心联立方程模型？](#chapter18)

[.red[Chapter 19. 联立方程模型的识别问题]](#chapter19)

[Chapter 20. 联立方程模型的估计方法](#chapter20)

]

---
layout: false
class: center, middle, duke-softblue,hide_logo
name: chapter19


# Chapter 19. 联立方程模型的识别问题

[19.1 识别类型](#definition)

[19.2 识别规则](#rule)

[19.3 内生性检验](#test-endogeneity)

[19.4 外生性检验](#test-exogeneity)

---
layout: false
class: center, middle, duke-softblue,hide_logo
name: definition

# 19.1 识别类型

---
layout: true

&lt;div class="my-header-h2"&gt;&lt;/div&gt;
&lt;div class="watermark1"&gt;&lt;/div&gt;
&lt;div class="watermark2"&gt;&lt;/div&gt;
&lt;div class="watermark3"&gt;&lt;/div&gt;

&lt;div class="my-footer"&gt;&lt;span&gt;huhuaping@ 
&lt;a href="#chapter-navi"&gt;模块04 联立方程模型（SEM） |&lt;/a&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;
&lt;a href="#chapter19"&gt;第19章 联立方程模型的识别问题 |&lt;/a&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;
&lt;a href="#definition"&gt; 19.1 模型识别的定义与类型 |&lt;/a&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;
&lt;/span&gt;&lt;/div&gt; 

---

### 识别问题的定义

**识别问题** (identification problem)，是指能否从所估计的约简型系数求出一个结构方程参数的估计值。

**识别的情形**：

- 如果能够求出估计值，就说该方程是**可以识别的**，具体又分为：

   - **恰好识别的**（充分或刚好识别的，Just/Exact Identiﬁcation）：是指能够得到结构参数的唯一数值。
   - **过度识别的**(Overidentiﬁcation)：是指可获得结构参数不止一个的值。
   
- 如果不能求出估计值，就说所考虑的方程是**不可识别的**或**识别不足的** (Underidentiﬁcation)。

---

### 识别问题的演示：联立方程

考虑如下的供需联立方程：

`$$\begin{align}
Q &amp;= \alpha_0+\alpha_1P_t+u_{t1}   &amp;(\alpha_1&lt;0)  &amp;&amp;\text{(需求函数)}\\
Q &amp;= \beta_0+\beta_1P_t+u_{t2}  &amp;(\beta_1&gt;0) &amp;&amp;\text{(供给函数)}\\
\end{align}$$`



---

### 识别问题的演示：散点图


&lt;div class="figure" style="text-align: center"&gt;
&lt;img src="SEM-slide-part2-identification_files/figure-html/plot1-scatter-1.png" alt="数量Q和价格P的散点分布"  /&gt;
&lt;p class="caption"&gt;数量Q和价格P的散点分布&lt;/p&gt;
&lt;/div&gt;


---

### 识别问题的演示：供需均衡点

&lt;div class="figure" style="text-align: center"&gt;
&lt;img src="SEM-slide-part2-identification_files/figure-html/plot2-inter-1.png" alt="每一散点代表一条需求曲线和一条供给曲线的交点。"  /&gt;
&lt;p class="caption"&gt;每一散点代表一条需求曲线和一条供给曲线的交点。&lt;/p&gt;
&lt;/div&gt;



---

### 识别问题的演示：不可识别

&lt;img src="SEM-slide-part2-identification_files/figure-html/plot3-both-1.png" style="display: block; margin: auto;" /&gt;

- 我们无法肯定这个点是由图中整个(供求)曲线族中的哪对供求曲线产生的。这时，我们就说供需曲线是**不可识别**的。

---

### 识别问题的演示：能识别出供给曲线

&lt;img src="SEM-slide-part2-identification_files/figure-html/plot4-demand-1.png" style="display: block; margin: auto;" /&gt;

- 如果由于收入、嗜好等等的变化，需求曲线随时间而移动，而供给曲线则保持相对稳定，则散点将展现出一条**供给曲线**。这时，我们就说供给曲线是**可识别**的。

---

### 识别问题的演示：能识别出需求曲线

&lt;img src="SEM-slide-part2-identification_files/figure-html/plot5-supply-1.png" style="display: block; margin: auto;" /&gt;

- 如果由于气候条件的变化或其他外部因素的变化，供给曲线随时间而移动，但需求曲线保持相对稳定，则散点将展现出一条**需求曲线**。这时，我们就说需求曲线是**可识别**的。

---

### 识别不足：结构方程和约简方程

给定联立方程：

`$$\begin{cases}
  \begin{align}
  Q_t &amp;= \alpha_0+\alpha_1P_t+u_{t1}   &amp;(\alpha_1&lt;0)  &amp;&amp;\text{(需求函数)}\\
  Q_t &amp;= \beta_0+\beta_1P_t+u_{t2}  &amp;(\beta_1&gt;0) &amp;&amp;\text{(供给函数)}\\
  \end{align}
\end{cases}$$`

.pull-left[

则容易得到约简方程形式：

`$$\begin{cases}
  \begin{align}
  P_t &amp;= \pi_{11}+v_{t1}  \\
  Q_t &amp;= \pi_{12}+v_{t2}   
  \end{align}
\end{cases}$$`

显然，前述的结构方程是**不可识别的**！

- 结构参数个数？
- 约简参数个数？

]

.pull-right[

其中，约简参数和结构参数的关系为：
`$$\begin{cases}
  \begin{align}
    \pi_{11} &amp; = -\frac{\alpha_0 - \beta_0}{\alpha_1-\beta_1}  \\
    \pi_{21} &amp; = \frac{\alpha_1\beta_0-\alpha_0\beta_1}{\alpha_1-\beta_1}  \\
    v_{t1} &amp;= - \frac{u_{t1} - u_{t2}}{\alpha_1-\beta_1}  \\
    v_{t2} &amp;= \frac{\alpha_1 u_{t2}- \alpha_0 u_{t1}}{\alpha_1-\beta_1}
  \end{align}
\end{cases}$$`

]


---

### 识别不足：虚构的一个“混杂”方程

针对结构方程，我们可以变换得到：

`$$\begin{cases}
  \begin{align}
  \lambda Q &amp;= \lambda\alpha_0+\lambda\alpha_1P_t+\lambda u_{t1}  &amp;(\alpha_1&lt;0)  &amp;&amp;\text{(需求函数变换)}\\
  (1-\lambda)Q &amp;= (1-\lambda)\beta_0+(1-\lambda)\beta_1P_t+(1-\lambda)u_{t2}  &amp;(\beta_1&gt;0) &amp;&amp;\text{(供给函数变换)}
  \end{align}
\end{cases}$$`

进一步，我们可以构造一个如下的“混杂”方程：

`$$\begin{align}
Q_t &amp;= \lambda\alpha_0+(1-\lambda)\beta_0 +(\lambda\alpha_1+(1-\lambda)\beta_1 )P_t+ \lambda u_{1t}+(1-\lambda)u_{t2}  &amp; &amp;&amp; \text{(混杂方程)} \\
\end{align}$$`

.pull-left[

并记为：

`$$\begin{align}
Q_t &amp;= \gamma_0 +\gamma_1P_t+w_t   \\
\end{align}$$`

- 该虚构的**混杂方程**与结构方程中的任何一个都是无差异的！
- 因此表明原来的结构方程是**不可识别的**！

]

.pull-right[

其中：

`$$\begin{cases}
  \begin{align}
  \gamma_0 &amp; = \lambda\alpha_0+(1-\lambda)\beta_0 \\
   \gamma_1 &amp;= \lambda\alpha_1+(1-\lambda)\beta_1  \\
   w_t &amp;= \lambda u_{1t}+(1-\lambda)u_{t2}  
  \end{align}
\end{cases}$$`

]

---

### 恰好识别：结构方程和约简方程

给定**结构方程**方程：

`$$\begin{cases}
  \begin{align}
  Q_t &amp;= \alpha_0+\alpha_1P_t+\alpha_2I_t+u_{t1}   &amp;(\alpha_1&lt;0,\alpha_2&gt;0)  &amp;&amp;\text{(需求函数)}\\
  Q_t &amp;= \beta_0+\beta_1P_t+u_{t2}  &amp;(\beta_1&gt;0) &amp;&amp;\text{(供给函数)}
  \end{align}
\end{cases}$$`

得到**约简方程**形式：

--

`$$\begin{cases}
  \begin{align}
  P_t &amp;= \pi_{11}+ \pi_{21}I_t+v_{t1} \\
  Q_t &amp;= \pi_{12}+ \pi_{22}I_t+v_{t2}\\
  \end{align}
\end{cases}$$`

其中：

`$$\begin{alignedat}{3}
&amp; \pi_{11} = \frac{\beta_0-\alpha_0}{\alpha_1-\beta_1}; \quad
&amp; \pi_{21} = - \frac{\alpha_2}{\alpha_1-\beta_1} ; \quad
&amp; v_{t1} = \frac{u_{t2}-u_{t1}}{\alpha_1-\beta_1} \\
&amp; \pi_{12} = \frac{\alpha_1\beta_0-\alpha_0\beta_1}{\alpha_1-\beta_1};\quad
&amp; \pi_{22} = - \frac{\alpha_2\beta_1}{\alpha_1-\beta_1} ;\quad
&amp; v_{t2} = \frac{\alpha_1u_{t2}-\beta_1u_{t1}}{\alpha_1-\beta_1}
\end{alignedat}$$`



---

### 恰好识别：只有一个方程能恰好识别

.pull-left[
前述结构方程能否识别么？


- 约简参数个数？

- 结构参数个数？

]

--

.pull-right[

**答案**：

- 只有4个约简参数：
`\(\pi_{11},\pi_{21},\pi_{12},\pi_{22}\)`
- 但是有5个结构参数：
`\(\alpha_0,\alpha_1,\alpha_2,\beta_0,\beta_1\)`
- 因此不可能完全求解全部5个结构参数

] 

--

然而，**供给方程**的结构参数是**恰好识别**的，因为：

`$$\begin{align}
\beta_0 = \pi_{12}-\beta_1\pi_{11} ; \quad
\beta_1 = \frac{\pi_{22}}{\pi_{21}}
\end{align}$$`

---

### 过度识别：结构方程

给定**结构方程**：

`$$\begin{cases}
  \begin{align}
  Q_t &amp;= \alpha_0+\alpha_1P_t+\alpha_2I_t+\alpha_3R_t+u_{t1} &amp;(\alpha_1&lt;0,\alpha_2&gt;0)  &amp;&amp;\text{(需求函数)}\\
  Q_t &amp;= \beta_0+\beta_1P_t+\beta_2P_{t-1}+u_{t2}   &amp;(\beta_1,\beta_2&gt;0) &amp;&amp;\text{(供给函数)}
  \end{align}
\end{cases}$$`


&lt;br&gt;

&gt; **提问**：请变换得到约简方程？

---

### 过度识别：约简方程

得到**约简方程**形式：

`$$\begin{cases}
  \begin{align}
  P_t &amp;= \pi_{11}+ \pi_{21}I_t+\pi_{31}R_t+\pi_{41}P_{t-1}+v_{t1} \\
  Q_t &amp;= \pi_{12}+\pi_{22}I_t+\pi_{32}R_t+\pi_{42}P_{t-1}+v_{t2}
  \end{align}
\end{cases}$$`


.pull-left[

`$$\begin{cases}
  \begin{align}
  &amp; \pi_{11} = \frac{\beta_0-\alpha_0}{\alpha_1-\beta_1} \\
  &amp; \pi_{21} = - \frac{\alpha_2}{\alpha_1-\beta_1} \\
  &amp; \pi_{31} = - \frac{\alpha_3}{\alpha_1-\beta_1} \\
  &amp; \pi_{41} = \frac{\beta_2}{\alpha_1-\beta_1} \\
  &amp; v_{t1} = \frac{u_{t2}-u_{t1}}{\alpha_1-\beta_1}  
  \end{align}
\end{cases}$$`

]

.pull-right[

`$$\begin{cases}
  \begin{align}
  &amp; \pi_{12} = - \frac{\alpha_1\beta_0-\alpha_0\beta_1}{\alpha_1-\beta_1} \\
  &amp; \pi_{22} = - \frac{\alpha_2\beta_1}{\alpha_1-\beta_1} \\
  &amp; \pi_{32} = - \frac{\alpha_3\beta_1}{\alpha_1-\beta_1} \\
  &amp; \pi_{42} =   \frac{\alpha_1\beta_2}{\alpha_1-\beta_1} \\
  &amp;v_{t2} = \frac{\alpha_1u_{t2}-\beta_1u_{t1}}{\alpha_1-\beta_1}
  \end{align}
\end{cases}$$`

]

---

### 过度识别：存在多个满足条件的解

.pull-left[
前述结构方程能否识别么？


- 约简参数个数？

- 结构参数个数？

]

--

.pull-right[

**答案**：

- 有8个**约简参数**：
`\(\pi_{11},\pi_{12},\pi_{13},\pi_{14},\pi_{21},\pi_{22},\pi_{23},\pi_{24}\)`
- 只有7个**结构参数**：
`\(\alpha_0,\alpha_1,\alpha_2,\alpha_3,\beta_0,\beta_1,\beta_2\)`
- 因此方程数多于未知系数个数，不能求解得出全部7个结构系数的唯一估计值。

] 

&lt;br&gt;

**结论**：结构方程存在多个满足条件的解，是**过度识别的**。



---
layout: false
class: center, middle, duke-softblue,hide_logo
name: rule

# 19.2 识别规则

---
layout: true

&lt;div class="my-header-h2"&gt;&lt;/div&gt;
&lt;div class="watermark1"&gt;&lt;/div&gt;
&lt;div class="watermark2"&gt;&lt;/div&gt;
&lt;div class="watermark3"&gt;&lt;/div&gt;

&lt;div class="my-footer"&gt;&lt;span&gt;huhuaping@ 
&lt;a href="#chapter-navi"&gt;模块04 联立方程模型（SEM） |&lt;/a&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;
&lt;a href="#chapter19"&gt;第19章 联立方程模型的识别问题 |&lt;/a&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;
&lt;a href="#rule"&gt; 19.2 识别规则 |&lt;/a&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;
&lt;/span&gt;&lt;/div&gt; 

---

### 符号约定

首先给出结构方程中**变量个数**的记号约定：

- 
`\(M=\)`
结构方程中全部内生变量的个数
- 
`\(m=\)`
某个方程中内生变量的个数
- 
`\(K=\)`
结构方程中全部前定变量的个数（包括截距项）
- 
`\(k=\)`
某定方程中前定变量的个数

---

### 可识别的阶条件：规则

**阶条件规则1**：

在一个含有M个方程的结构模型中，一个方程能被识别，它必须**排除**——在联立模型中出现而它自己不出现的——至少M-1个变量（包括**内生或前定**）。也即
`\(M+K-(k+m) \geq (M-1)\)`。

- 如果它恰好有M-1个（内生或前定）变量没有出现，则该方程是**恰好识别的**。也即，
`\(M+K-(k+m) = (M-1)\)`
- 如果它超过M-1个（内生或前定）变量没有出现，则该方程是**过度识别的**；也即，
`\(M+K-(k+m) &gt; (M-1)\)`

---

### 可识别的阶条件：规则

**阶条件规则2**：

在一个含有M个方程的结构模型中，一个方程能被识别，该方程所**排除的**——在联立模型中出现而它自己不出现——**前定变量**个数必须多于它所含的内生变量的个数减1，也即
`\(K-k \geq m-1\)`。

- 如果
`\(K-k = m-1\)`
，则该方程是**恰好识别的**；

- 如果
`\(K-k \geq m-1\)`
，则该方程是**过度识别的**。

???
容易证明，二者是等价的。Why？

---

### 可识别的阶条件：示例1（都不可识别）

有如下的**结构方程**：

`$$\begin{cases}
  \begin{align}
  Q_t &amp;= \alpha_0+\alpha_1P_t+u_{t1}   &amp;(\alpha_1&lt;0)  &amp;&amp;\text{(需求函数)}\\
  Q_t &amp;= \beta_0+\beta_1P_t+u_{t2}  &amp;(\beta_1&gt;0) &amp;&amp;\text{(供给函数)}\\
  \end{align}
\end{cases}$$`


**阶条件规则1**的结论：

--

- 结构方程的全部变量有(M+K)=2+0=2个，且(M-1)=2-1=1
- 对于第1个方程，因为其全部变量数有(m+k)=2+0=2个，所以(M+K)-(m+k)=2-2=0，显然(M+K)-(m+k)&lt;(M-1)。因此第一个方程（需求方程）是**不可识别的**
- 对于第二个方程，因为(m+k)=2+0=2，所以(M+K)-(m+k)=2-2=0，显然(M+K)-(m+k)&lt;(M-1)。因此第二个方程（供给方程）也是**不可识别的**

---

### 可识别的阶条件：示例1（都不可识别）

有如下的**结构方程**：

`$$\begin{cases}
  \begin{align}
  Q_t &amp;= \alpha_0+\alpha_1P_t+u_{t1}   &amp;(\alpha_1&lt;0)  &amp;&amp;\text{(需求函数)}\\
  Q_t &amp;= \beta_0+\beta_1P_t+u_{t2}  &amp;(\beta_1&gt;0) &amp;&amp;\text{(供给函数)}\\
  \end{align}
\end{cases}$$`

**阶条件规则2**的结论：

--

- 结构方程中前定变量个数K=0
- 对于第1个方程，前定变量个数k=0，则(K-k)=0；第1个方程的内生变量个数m=1，则(m-1)=1；显然(K-k)&lt;(m-1)。因此第1个方程（需求方程）是**不可识别的**
- 对于第2个方程，前定变量个数k=0，则(K-k)=0；第2个方程的内生变量个数m=1，则(m-1)=1；显然(K-k)&lt;(m-1)。因此第2个方程（供给方程）是**不可识别的**
    
---

### 可识别的阶条件：示例2（不可识别+恰好识别）

给定**结构方程**方程：

`$$\begin{cases}
  \begin{align}
  Q_t &amp;= \alpha_0+\alpha_1P_t+\alpha_2I_t+u_{t1}   &amp;(\alpha_1&lt;0,\alpha_2&gt;0)  &amp;&amp;\text{(需求函数)}\\
  Q_t &amp;= \beta_0+\beta_1P_t+u_{t2}  &amp;(\beta_1&gt;0) &amp;&amp;\text{(供给函数)}
  \end{align}
\end{cases}$$`

**阶条件规则1**的结论：

--

- 结构方程中(M+K)=2+1=3，且(M-1)=2-1=1
- 对于第1个方程，因为(m+k)=2+1=3，所以(M+K)-(m+k)=3-3=0，显然(M+K)-(m+k)&lt;(M-1)。第1个方程（需求方程）是**不可识别的**
- 对于第2个方程，因为(m+k)=2+0=2，所以(M+K)-(m+k)=3-2=1，显然(M+K)-(m+k)=(M-1)。第2个方程（供给方程）是**恰好识别的**

---

### 可识别的阶条件：示例2（不可识别+恰好识别）

给定**结构方程**方程：

`$$\begin{cases}
  \begin{align}
  Q_t &amp;= \alpha_0+\alpha_1P_t+\alpha_2I_t+u_{t1}   &amp;(\alpha_1&lt;0,\alpha_2&gt;0)  &amp;&amp;\text{(需求函数)}\\
  Q_t &amp;= \beta_0+\beta_1P_t+u_{t2}  &amp;(\beta_1&gt;0) &amp;&amp;\text{(供给函数)}
  \end{align}
\end{cases}$$`

**阶条件规则2**的结论：

--

- 结构方程中前定变量个数K=1
- 对于第1个方程，前定变量个数k=1，则(K-k)=0；第一个方程的内生变量个数m=2，则(m-1)=1；显然(K-k)&lt;(m-1)。因此第一个方程（需求方程）是**不可识别的**
- 对于第2个方程，前定变量个数k=0，则(K-k)=1；第二个方程的内生变量个数m=2，则(m-1)=1；显然(K-k)=(m-1)。因此第二个方程（供给方程）是**恰好识别的**

---

### 可识别的阶条件：示例3（恰好识别+过度识别）


给定**结构方程**：

`$$\begin{cases}
  \begin{align}
  Q_t &amp;= \alpha_0+\alpha_1P_t+\alpha_2I_t+\alpha_3R_t+u_{t1} &amp;(\alpha_1&lt;0,\alpha_2&gt;0)  &amp;&amp;\text{(需求函数)}\\
  Q_t &amp;= \beta_0+\beta_1P_t+\beta_2P_{t-1}+u_{t2}   &amp;(\beta_1,\beta_2&gt;0) &amp;&amp;\text{(供给函数)}
  \end{align}
\end{cases}$$`

**阶条件规则1**的结论：

--

- 结构方程中(M+K)=2+3=5，且(M-1)=2-1=1
- 对于第1个方程，因为(m+k)=2+2=4，所以(M+K)-(m+k)=5-4=1，显然(M+K)-(m+k)=(M-1)。第1个方程（需求方程）是**恰好识别的**
- 对于第二个方程，因为(m+k)=2+1=3，所以(M+K)-(m+k)=5-3=2，显然(M+K)-(m+k)&gt;(M-1)。第2个方程（供给方程）是**过度识别的**

---

### 可识别的阶条件：示例3（恰好识别+过度识别）


给定**结构方程**：

`$$\begin{cases}
  \begin{align}
  Q_t &amp;= \alpha_0+\alpha_1P_t+\alpha_2I_t+\alpha_3R_t+u_{t1} &amp;(\alpha_1&lt;0,\alpha_2&gt;0)  &amp;&amp;\text{(需求函数)}\\
  Q_t &amp;= \beta_0+\beta_1P_t+\beta_2P_{t-1}+u_{t2}   &amp;(\beta_1,\beta_2&gt;0) &amp;&amp;\text{(供给函数)}
  \end{align}
\end{cases}$$`

**阶条件规则2**的结论：

--

- 结构方程中前定变量个数K=3
- 对于第1个方程，前定变量个数k=2，则(K-k)=1；第1个方程的内生变量个数m=2，则(m-1)=1；显然(K-k)=(m-1)。因此第1个方程（需求方程）是**恰好识别的**
- 对于第2个方程，前定变量个数k=1，则(K-k)=2；第2个方程的内生变量个数m=2，则(m-1)=1；显然(K-k)&gt;(m-1)。因此第2个方程（供给方程）是**过度识别的**

---

### 可识别的阶条件：总结


阶条件规则是识别的**必要而非充分条件**，即使它得到满足，方程也会出现不能识别的情形。例如：

`$$\begin{align}
Q &amp;= \alpha_0+\alpha_1P_t+\alpha_2I_t+u_{t1}   &amp;(\alpha_1&lt;0,\alpha_2&gt;0)  &amp;&amp;\text{(需求函数)}\\
Q &amp;= \beta_0+\beta_1P_t+u_{t2}  &amp;(\beta_1&gt;0) &amp;&amp;\text{(供给函数)}
\end{align}$$`

根据阶条件规则，我们判断第二个方程（供给方程）是**恰好可识别的**。但实际上，我们还需要确保第一个方程中的收入
    `\(I_t\)`
    前面的系数
    `\(\alpha_2 \neq 0\)`
    。也就是说，收入变量不仅仅有可能进入而且**确实**进入了需求函数。


- 阶条件规则1和阶条件规则2是等价的。


- 利用阶条件规则判断识别问题，适合于比较简单的联立方程情形。

---

### 可识别的秩条件

**秩条件规则**：

- 在一个包含M个内生变量的M个方程的联立模型中，一个方程可识别的**充分必要**条件是，我们能从模型所含而该方程所不含的（内生或前定）变量系数矩阵中构造出**至少**1个
`\((M-1)\ast(M-1)\)`
阶的非零行列式来。

**主要操作步骤**：

- 把结构模型移项，写出**代数式2**

- 按方程写出对应的**系数列表**

- 找到该方程不含的所有**列**

- 从这些列中随意找出1个
`\((M-1)\ast(M-1)\)`的矩阵

- 判断并得出结论：如果能找到任何1个行列式为0的矩阵，则该方程就是**不可识别的**

---

### 可识别的秩条件：示例（写出代数式2；写出系数列表）

`$$\begin{cases}
  \begin{alignedat}{9}
&amp;  Y_{t1} &amp;-\gamma_{21}Y_{t2}&amp;-\gamma_{31}Y_{t3} &amp; &amp;-\beta_{01}&amp;-\beta_{11}X_{t1} &amp;  &amp; &amp;= &amp;u_{t1} \\
&amp; &amp; Y_{t2} &amp;-\gamma_{32} Y_{3t} &amp; &amp; -\beta_{02}&amp;-\beta_{12}X_{1t} &amp;- \beta_{22}X_{2t} &amp; &amp;= &amp;u_{t2}\\
&amp;-\gamma_{13}Y_{t1} &amp;  &amp;+ Y_{t3} &amp; &amp; -\beta_{03}&amp;-\beta_{13}X_{1t} &amp;-\beta_{23}X_{2t} &amp; &amp;= &amp;u_{t3} \\
&amp;-\gamma_{14}Y_{t1}&amp;-\gamma_{24}Y_{t2} &amp;  &amp;+Y_{t4}   &amp;-\beta_{04} &amp; &amp; &amp;-\beta_{34}X_{t3} &amp;= &amp;u_{t4} 
  \end{alignedat}
\end{cases}$$`


可以将上述结构方程的参数写成如下的形式：

`$$\begin{matrix}
--   &amp; --  &amp; --  &amp; --  &amp; --  &amp;  --&amp; --  &amp; --  &amp; --  \\ 
eq   &amp; Y_1 &amp; Y_2 &amp; Y_3 &amp; Y_4 &amp;   1&amp; X_1 &amp; X_2 &amp; X_3 \\
--   &amp;  -- &amp; --  &amp; --  &amp; --  &amp; -- &amp; --  &amp; --  &amp; --  \\ 
1   &amp; 1 &amp; -\gamma_{21} &amp; -\gamma_{31} &amp; 0 &amp; -\beta_{01}&amp; -\beta_{11} &amp; 0 &amp; 0 \\
2   &amp; 0 &amp; 1 &amp; -\gamma_{32} &amp; 0 &amp; -\beta_{02}&amp; -\beta_{12} &amp; -\beta_{22} &amp; 0 \\
3   &amp; -\gamma_{13} &amp; 0 &amp; 1 &amp; 0 &amp; -\beta_{03}&amp; -\beta_{13} &amp; -\beta_{23} &amp; 0 \\
4   &amp; -\gamma_{14} &amp; -\gamma_{24} &amp; 0 &amp; 1 &amp; -\beta_{04}&amp; 0 &amp; 0 &amp; -\beta_{34} \\
\end{matrix}$$`

---

### 可识别的秩条件：示例（分析第1个方程的变量数;找到缺失列）

`$$\begin{cases}
  \begin{alignedat}{9}
&amp;  Y_{t1} &amp;-\gamma_{21}Y_{t2}&amp;-\gamma_{31}Y_{t3} &amp; &amp;-\beta_{01}&amp;-\beta_{11}X_{t1} &amp;  &amp; &amp;= &amp;u_{t1} \\
&amp; &amp; Y_{t2} &amp;-\gamma_{32} Y_{3t} &amp; &amp; -\beta_{02}&amp;-\beta_{12}X_{1t} &amp;- \beta_{22}X_{2t} &amp; &amp;= &amp;u_{t2}\\
&amp;-\gamma_{13}Y_{t1} &amp;  &amp;+ Y_{t3} &amp; &amp; -\beta_{03}&amp;-\beta_{13}X_{1t} &amp;-\beta_{23}X_{2t} &amp; &amp;= &amp;u_{t3} \\
&amp;-\gamma_{14}Y_{t1}&amp;-\gamma_{24}Y_{t2} &amp;  &amp;+Y_{t4}   &amp;-\beta_{04} &amp; &amp; &amp;-\beta_{34}X_{t3} &amp;= &amp;u_{t4} 
  \end{alignedat}
\end{cases}$$`

- 第1个方程不包含的内生变量有：
`\(Y_{t4}\)`；不包含的前定变量有：
`\(X_{t2},X_{t3}\)`

`$$\begin{matrix}
--   &amp; --  &amp; --  &amp; --  &amp; --  &amp;  --&amp; --  &amp; --  &amp; --  \\ 
eq   &amp; Y_1 &amp; Y_2 &amp; Y_3 &amp; [Y_4] &amp;   1&amp; X_1 &amp; [X_2] &amp; [X_3] \\
--   &amp;  -- &amp; --  &amp; --  &amp; --  &amp; -- &amp; --  &amp; --  &amp; --  \\ 
1   &amp; 1 &amp; -\gamma_{21} &amp; -\gamma_{31} &amp; 0 &amp; -\beta_{01}&amp; -\beta_{11} &amp; 0 &amp; 0 \\
2   &amp; 0 &amp; 1 &amp; -\gamma_{32} &amp; 0 &amp; -\beta_{02}&amp; -\beta_{12} &amp; -\beta_{22} &amp; 0 \\
3   &amp; -\gamma_{13} &amp; 0 &amp; 1 &amp; 0 &amp; -\beta_{03}&amp; -\beta_{13} &amp; -\beta_{23} &amp; 0 \\
4   &amp; -\gamma_{14} &amp; -\gamma_{24} &amp; 0 &amp; 1 &amp; -\beta_{04}&amp; 0 &amp; 0 &amp; -\beta_{34} \\
\end{matrix}$$`


---

### 可识别的秩条件：示例（找1个目标矩阵；计算其行列式）

`$$\begin{matrix}
--   &amp; --  &amp; --  &amp; --  &amp; --  &amp;  --&amp; --  &amp; --  &amp; --  \\ 
eq   &amp; Y_1 &amp; Y_2 &amp; Y_3 &amp; [Y_4] &amp;   1&amp; X_1 &amp; [X_2] &amp; [X_3] \\
--   &amp;  -- &amp; --  &amp; --  &amp; --  &amp; -- &amp; --  &amp; --  &amp; --  \\ 
1   &amp; 1 &amp; -\gamma_{21} &amp; -\gamma_{31} &amp; 0 &amp; -\beta_{01}&amp; -\beta_{11} &amp; 0 &amp; 0 \\
2   &amp; 0 &amp; 1 &amp; -\gamma_{32} &amp; 0 &amp; -\beta_{02}&amp; -\beta_{12} &amp; -\beta_{22} &amp; 0 \\
3   &amp; -\gamma_{13} &amp; 0 &amp; 1 &amp; 0 &amp; -\beta_{03}&amp; -\beta_{13} &amp; -\beta_{23} &amp; 0 \\
4   &amp; -\gamma_{14} &amp; -\gamma_{24} &amp; 0 &amp; 1 &amp; -\beta_{04}&amp; 0 &amp; 0 &amp; -\beta_{34} \\
\end{matrix}$$`

.pull-left[

`$$\begin{alignat}{3}
A= 
  \begin{bmatrix}
  0 &amp; -\beta_{22} &amp;  0 \\
  0 &amp; -\beta_{32} &amp; 0 \\
  1 &amp; 0 &amp;  -\beta_{43} \\
  \end{bmatrix}
\end{alignat}$$`
]

.pull-right[

`$$\begin{alignat}{3}
det(A)= 
  \begin{vmatrix}
  0 &amp; -\beta_{22} &amp;  0 \\
  0 &amp; -\beta_{32} &amp; 0 \\
  1 &amp; 0 &amp;  -\beta_{43} \\
  \end{vmatrix}
=0
\end{alignat}$$`
]

这意味着，矩阵的秩
`\(rank(A)=\mathbf{\rho}(A)&lt;3\)`。因此，**第一个方程**不满足秩条件，**不能识别**。

???
我们可以得到其中一个的一个矩阵为：
显然，该矩阵的行列式等于0：

---

### 可识别的秩条件：总结

总结起来，秩条件识别规则的步骤如下：

.pull-left[

- 把**结构方程**写成**代数式2**

- 把**系数**写成表格形式

- 划掉被考虑的方程所在行

- 再划掉被考虑的方程中**非零系数**对应的列

- 余下的系数将构成一个**系数矩阵**

]

.pull-right[

- 利用**系数矩阵**，构造任意的
`\((M-1)*(M-1)\)`
阶方阵，并计算方阵的行列式
- 如果能找到**至少一个**行列式不等于零的
`\((M-1)*(M-1)\)`
阶方阵，也即该方阵的秩为M-1，则表明被考虑方程是**可识别的**（恰好或多度识别）

- 如果所有可能的
`\((M-1)*(M-1)\)`
阶方阵，它们的行列式全等于零，也即所有可能
`\((M-1)*(M-1)\)`
阶方阵的秩都**小于**M-1，则表明被考虑方程是**不可识别的**

]

---

### 可识别的秩条件：示例（练习，其他3个方程是否可识别？）

`$$\begin{matrix}
--   &amp; --  &amp; --  &amp; --  &amp; --  &amp;  --&amp; --  &amp; --  &amp; --  \\ 
eq   &amp; Y_1 &amp; Y_2 &amp; Y_3 &amp; Y_4 &amp;   1&amp; X_1 &amp; X_2 &amp; X_3 \\
--   &amp;  -- &amp; --  &amp; --  &amp; --  &amp; -- &amp; --  &amp; --  &amp; --  \\ 
1   &amp; 1 &amp; -\gamma_{21} &amp; -\gamma_{31} &amp; 0 &amp; -\beta_{01}&amp; -\beta_{11} &amp; 0 &amp; 0 \\
2   &amp; 0 &amp; 1 &amp; -\gamma_{32} &amp; 0 &amp; -\beta_{02}&amp; -\beta_{12} &amp; -\beta_{22} &amp; 0 \\
3   &amp; -\gamma_{13} &amp; 0 &amp; 1 &amp; 0 &amp; -\beta_{03}&amp; -\beta_{13} &amp; -\beta_{23} &amp; 0 \\
4   &amp; -\gamma_{14} &amp; -\gamma_{24} &amp; 0 &amp; 1 &amp; -\beta_{04}&amp; 0 &amp; 0 &amp; -\beta_{34} \\
\end{matrix}$$`

**答案**：

- 第1个方程：不可识别

- 第2个方程：？

- 第3个方程：？

- 第4个方程：？

???
第4个是可识别的，其他都不可识别！

---

### 可识别的秩条件：与阶条件判断法进行比较

`$$\begin{cases}
  \begin{alignedat}{9}
&amp;  Y_{t1} &amp;-\gamma_{21}Y_{t2}&amp;-\gamma_{31}Y_{t3} &amp; &amp;-\beta_{01}&amp;-\beta_{11}X_{t1} &amp;  &amp; &amp;= &amp;u_{t1} \\
&amp; &amp; Y_{t2} &amp;-\gamma_{32} Y_{3t} &amp; &amp; -\beta_{02}&amp;-\beta_{12}X_{1t} &amp;- \beta_{22}X_{2t} &amp; &amp;= &amp;u_{t2}\\
&amp;-\gamma_{13}Y_{t1} &amp;  &amp;+ Y_{t3} &amp; &amp; -\beta_{03}&amp;-\beta_{13}X_{1t} &amp;-\beta_{23}X_{2t} &amp; &amp;= &amp;u_{t3} \\
&amp;-\gamma_{14}Y_{t1}&amp;-\gamma_{24}Y_{t2} &amp;  &amp;+Y_{t4}   &amp;-\beta_{04} &amp; &amp; &amp;-\beta_{34}X_{t3} &amp;= &amp;u_{t4} 
  \end{alignedat}
\end{cases}$$`

下面我们再运用**识别的阶条件**对所有方程进行判断，可以得到下面结果：

<div id="htmlwidget-8efdbe60b184c9061fed" style="width:100%;height:auto;" class="datatables html-widget"></div>
<script type="application/json" data-for="htmlwidget-8efdbe60b184c9061fed">{"x":{"filter":"none","data":[["1","2","3","4"],[1,2,3,4],[3,2,2,3],[1,2,2,1],[4,4,4,4],[3,3,3,3],[2,1,1,2],[2,1,1,2],["恰好识别","恰好识别","恰好识别","恰好识别"]],"container":"<table class=\"display\">\n  <thead>\n    <tr>\n      <th> <\/th>\n      <th>eq<\/th>\n      <th>m<\/th>\n      <th>k<\/th>\n      <th>M<\/th>\n      <th>K<\/th>\n      <th>K-k<\/th>\n      <th>m-1<\/th>\n      <th>结论<\/th>\n    <\/tr>\n  <\/thead>\n<\/table>","options":{"dom":"t","columnDefs":[{"className":"dt-center","targets":"_all"},{"visible":false,"targets":0},{"orderable":false,"targets":0}],"pageLength":6,"order":[],"autoWidth":false,"orderClasses":false,"lengthMenu":[6,10,25,50,100]}},"evals":[],"jsHooks":[]}</script>


---

### 识别规则的总结

下面对识别规则进行一个全面总结：

- 阶条件是识别的**必要但非充分条件**，即使它得到满足，方程也会出现不能识别的情形。

- 秩条件是识别的**充分必要条件**

- **秩条件**告诉我们所考虑的方程**是否可识别**，而**阶条件**告诉我们它是**恰好识别**还是**过度识别**

- 严格地，我们需要先分析秩条件，确定方程是否可识别；然后再利用阶条件，判断是恰好识别还是过度识别！

---
layout: false
class: center, middle, duke-softblue,hide_logo
name: test-endogeneity

# 19.3 内生性检验

---
layout: true

&lt;div class="my-header-h2"&gt;&lt;/div&gt;
&lt;div class="watermark1"&gt;&lt;/div&gt;
&lt;div class="watermark2"&gt;&lt;/div&gt;
&lt;div class="watermark3"&gt;&lt;/div&gt;

&lt;div class="my-footer"&gt;&lt;span&gt;huhuaping@ 
&lt;a href="#chapter-navi"&gt;模块04 联立方程模型（SEM） |&lt;/a&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;
&lt;a href="#chapter19"&gt;第19章 联立方程模型的识别问题 |&lt;/a&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;
&lt;a href="#test-endogeneity"&gt; 19.3 内生性检验 |&lt;/a&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;
&lt;/span&gt;&lt;/div&gt; 


---

### 联立性检验（内生性检验）：概念与定义

联立性检验在本质上是检验一个（内生）回归元是否与误差项（
`\(u_t\)`
）相关。

- 如果相关，就存在联立性问题，从而需要找到不同于OLS的估计方法；

- 如果不相关，则认为不存在联立性问题，可以继续使用OLS方法

--

**豪斯曼设定误差检验** (Hausman specification error test)的**一种形式**可用于检验联立性问题。

**豪斯曼联立性检验**又被称为**豪斯曼内生性检验** (Hausman test of endogeneity)

---

### 联立性检验（内生性检验）：检验的原理


给定联立方程：

`$$\begin{align}
Q &amp;= \alpha_0+\alpha_1P_t+\alpha_2I_t+\alpha_3R_t+u_{t1}   &amp;(\alpha_1&lt;0,\alpha_2&gt;0)  &amp;&amp;\text{(需求函数)}\\
Q &amp;= \beta_0+\beta_1P_t+u_{t2}  &amp;(\beta_1&gt;0) &amp;&amp;\text{(供给函数)}
\end{align}$$`

其中： P=价格；I=收入；R=财富

很容易得到约简方程：

`$$\begin{align}
P_t &amp;= \pi_{11}+ \pi_{21}I_t + \pi_{31} R_t + v_{t1} &amp;&amp;\text{(约简方程1)}\\
Q_t &amp;= \pi_{12}+ \pi_{22}I_t + \pi_{33} R_t + v_{t2} &amp;&amp;\text{(约简方程2)} 
\end{align}$$`

---

### 联立性检验（内生性检验）：检验的原理

我们可以直接用OLS方法估计约简方程1（价格方程），得到：

`$$\begin{align}
P_t &amp;= \hat{\pi}_{11}+ \hat{\pi}_{21}I_t + \hat{\pi}_{31} R_t + \hat{v}_{t1} &amp;&amp;\text{(价格方程的OLS估计)} \\
    &amp;= \hat{P_t} +\hat{v}_{t1}
\end{align}$$`

进而可以将价格方程的OLS估计结果带入如下**检验方程**，并做如下的OLS估计：

`$$\begin{align}
Q_t &amp;= \beta_0+\beta_1\hat{P_t} + \beta_1 \hat{v}_{t1} +u_{t2} &amp; &amp;&amp; \text{(豪斯曼检验方程)}\\
Q_t &amp;= \beta_0+\beta_1 {P_t} + \beta_1\hat{v}_{t1} +u_{t2} &amp; &amp;&amp;\text{(平狄克检验方程)} \\
\end{align}$$`

---

### 联立性检验（内生性检验）：检验的原理

豪斯曼联立性检验下：

- 原假设
`\(H_0\)`
：无联立性问题，要求
`\(\hat{v}_{t1}\)`
和
`\(u_{t2}\)`
不相关；
- 备择假设
`\(H_1\)`
：有联立性问题，要求
`\(\hat{v}_{t1}\)`
和
`\(u_{t2}\)`
相关；


因此，只需要**检验方程**参数
`\(\beta_1\)`
进行检验：

- 如果
`\(\beta_1\)`
统计上**不显著**，则不能拒绝原假设
`\(H_0\)`
，认为**无联立性问题**
- 如果
`\(\beta_1\)`
统计**显著**，则拒绝原假设
`\(H_0\)`
，接受备择假设
`\(H_1\)`
，认为**存在联立性问题**



---

### 联立性检验（内生性检验）

因此，豪斯曼检验的步骤包括：

- step 1：利用OLS方法，做
`\(P_t = \hat{\pi}_{11}+ \hat{\pi}_{21}I_t + \hat{\pi}_{31} R_t + \hat{v}_{t1}\)`
的回归，得到
`\(\hat{v_t}\)`

- step 2：利用OLS方法，做
`\(Q_t = \beta_0+\beta_1 \hat{P_t} + \beta_1\hat{v}_{t1} +u_{t2}\)`
的回归，并对
`\(\hat{v}_{1t}\)`
的系数进行t检验，并作出联立性问题的判断。 需要注意的是，为了更有效地估计，平狄克 (Pindyck) 和鲁宾费尔德 (Rubinfeld) 建议对
`\(Q_t = \beta_0+\beta_1 P_t + \beta_1\hat{v}_{t1} +u_{t2}\)`
的回归。

---

### 联立性检验：松露案例（结构和约简方程）

我们仍旧以松露案例模型为例，给定如下联立方程：

`$$\begin{align}
Q_i &amp;= \alpha_0+\alpha_1P_i+\alpha_2PS_i+\alpha_3DI_i+u_{i1}  &amp;&amp;\text{(需求函数)}\\
Q_i &amp;= \beta_0+\beta_1P_i+\beta_2PF_i+u_{i2}    &amp;&amp;\text{(供给函数)}
\end{align}$$`

很快可以得到约简方程：

`$$\begin{align}
P_i &amp;= \pi_{11}+ \pi_{21}PS_i+\pi_{31}DI_i+\pi_{41}PF_i+v_{i1} \\
Q_i &amp;= \pi_{12}+\pi_{22}PS_t+\pi_{32}DI_t+\pi_{42}PF_i+v_{i2} 
\end{align}$$`

---

### 联立性检验：松露案例（结构和约简系数）

其中**约简系数**和**结构系数**的关系为：

.pull-left[
`$$\begin{cases}
  \begin{align}
  &amp; \pi_{11} = \frac{\beta_0-\alpha_0}{\alpha_1-\beta_1}\\
  &amp; \pi_{21} = - \frac{\alpha_2}{\alpha_1-\beta_1}\\
  &amp; \pi_{31} = - \frac{\alpha_3}{\alpha_1-\beta_1}\\
  &amp; \pi_{41} = \frac{\beta_2}{\alpha_1-\beta_1}\\
  &amp; v_{i1} = \frac{u_{i2}-u_{i1}}{\alpha_1-\beta_1}  
  \end{align}
\end{cases}$$`

]

.pull-right[

`$$\begin{cases}
  \begin{align}
  &amp; \pi_{12} = - \frac{\alpha_1\beta_0-\alpha_0\beta_1}{\alpha_1-\beta_1}  \\
  &amp; \pi_{22} = - \frac{\alpha_2\beta_1}{\alpha_1-\beta_1} \\
  &amp; \pi_{32} = - \frac{\alpha_3\beta_1}{\alpha_1-\beta_1} \\
  &amp; \pi_{42} =   \frac{\alpha_1\beta_2}{\alpha_1-\beta_1} \\
  &amp; v_{i2} = \frac{\alpha_1u_{i2}-\beta_1u_{i1}}{\alpha_1-\beta_1} 
  \end{align}
\end{cases}$$`

]

---

### 联立性检验：松露案例（OLS估计价格方程）

按照豪斯曼联立性检验的**第一个步骤**，利用OLS方法回归如下价格**约简方程**，并得到
`\(\hat{P_i},\hat{v}_{i1}\)`

`$$\begin{align}
P_i &amp; = \hat{\pi}_{11}+ \hat{\pi}_{21} PS_i + \hat{\pi}_{31} DI_i + \hat{\pi}_{41} PF_i + \hat{v}_{i1} \\
    &amp; = \hat{P_i} + \hat{v}_{i1}
\end{align}$$`

---

### 联立性检验：松露案例（OLS估计价格方程；R原始报告）



约简方程1（价格方程）的原始回归结果报告如下：

```

Call:
lm(formula = Hausman_models$mod.P, data = truffles)

Residuals:
     Min       1Q   Median       3Q      Max 
-20.4825  -3.5927   0.2801   4.5326  12.9210 

Coefficients:
            Estimate Std. Error t value Pr(&gt;|t|)    
(Intercept) -32.5124     7.9842  -4.072 0.000387 ***
PS            1.7081     0.3509   4.868 4.76e-05 ***
DI            7.6025     1.7243   4.409 0.000160 ***
PF            1.3539     0.2985   4.536 0.000115 ***
---
Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1

Residual standard error: 6.597 on 26 degrees of freedom
Multiple R-squared:  0.8887,	Adjusted R-squared:  0.8758 
F-statistic: 69.19 on 3 and 26 DF,  p-value: 1.597e-12
```


---

### 联立性检验：松露案例（OLS估计价格方程；精简报告）

约简方程1（价格方程）的精简回归报告如下：

`$$\begin{alignedat}{999}
&amp;\widehat{P}=&amp;&amp;-32.51&amp;&amp;+1.71PS&amp;&amp;+7.60DI&amp;&amp;+1.35PF\\
&amp;\text{(t)}&amp;&amp;(-4.0721)&amp;&amp;(4.8682)&amp;&amp;(4.4089)&amp;&amp;(4.5356)\\
&amp;\text{(se)}&amp;&amp;(7.9842)&amp;&amp;(0.3509)&amp;&amp;(1.7243)&amp;&amp;(0.2985)\\
&amp;\text{(fitness)}&amp;&amp; n=30;&amp;&amp; R^2=0.8887;&amp;&amp; \bar{R^2}=0.8758\\
&amp; &amp;&amp; F^{\ast}=69.19;&amp;&amp; p=0.0000\\
\end{alignedat}$$`

请解释回归结果？？

---

### 联立性检验：松露案例（OLS估计价格方程；估计得到的变量）

进而可以分别估计得到
`\(\hat{P_i},\hat{v}_{i1}\)`

<div id="htmlwidget-4b95f91c8c07b42d1bee" style="width:100%;height:auto;" class="datatables html-widget"></div>
<script type="application/json" data-for="htmlwidget-4b95f91c8c07b42d1bee">{"x":{"filter":"none","caption":"<caption>估计价格方程并得到hat.Pi和hat.v1i<\/caption>","data":[["1","2","3","4","5","6","7","8","9","10","11","12","13","14","15","16","17","18","19","20","21","22","23","24","25","26","27","28","29","30"],[29.64,40.23,34.71,41.43,53.37,38.52,54.33,40.56,67.35,49.65,58.17,66.87,49.95,64.95,52.68,61.2,80.55,89.94,70.77,57.33,46.23,77.43,83.01,70.71,66.75,76.8,83.7,81,88.44,105.45],[19.89,13.04,19.61,17.13,22.55,6.37,15.02,10.22,23.64,16.12,24.55,18.92,11.94,18.93,12.6,20.49,22.94,21.08,16.68,17.61,16.62,20.99,24.53,19.67,23.29,16.64,20.81,14.95,26.27,20.65],[19.97,18.04,22.36,20.87,19.79,15.98,17.94,17.09,22.72,15.74,24.64,23.7,15.93,23.34,15.21,26.04,22.95,27.1,23.65,20.06,26.38,24.28,26.64,22.65,19.68,23.82,28.98,18.52,28.16,28.43],[2.103,2.043,1.87,1.525,2.709,2.489,2.294,2.196,3.885,3.169,2.623,3.007,3.367,3.29,3.746,3.518,4.381,4.121,3.82,4.398,3.764,4.524,4.815,3.67,4.392,4.603,4.632,4.894,5.125,4.836],[10.52,19.67,13.74,17.95,13.71,24.95,24.17,23.61,19.52,20.03,15.38,22.98,25.76,25.17,25.82,19.31,26.02,29.65,27.45,18,18.87,24.58,25.25,24.24,22.63,27.35,27.8,30.34,24.12,34.01],[31.8304,40.4658,38.5011,39.033,40.449,47.4863,48.2958,45.3406,62.2606,45.5848,50.3407,61.9441,55.1726,66.4457,56.9053,64.8572,75.2247,85.2515,74.0915,59.5591,66.7125,76.6341,83.7847,66.8969,65.1329,80.1992,89.843,77.4066,87.208,98.8622],[-2.1904,-0.2358,-3.7911,2.397,12.921,-8.9663,6.0342,-4.7806,5.0894,4.0652,7.8293,4.9259,-5.2226,-1.4957,-4.2253,-3.6572,5.3253,4.6885,-3.3215,-2.2291,-20.4825,0.7959,-0.7747,3.8131,1.6171,-3.3992,-6.143,3.5934,1.232,6.5878]],"container":"<table class=\"display\">\n  <thead>\n    <tr>\n      <th> <\/th>\n      <th>P<\/th>\n      <th>Q<\/th>\n      <th>PS<\/th>\n      <th>DI<\/th>\n      <th>PF<\/th>\n      <th>hat.Pi<\/th>\n      <th>hat.vi<\/th>\n    <\/tr>\n  <\/thead>\n<\/table>","options":{"dom":"tip","columnDefs":[{"className":"dt-center","targets":"_all"},{"visible":false,"targets":0},{"orderable":false,"targets":0}],"pageLength":8,"order":[],"autoWidth":false,"orderClasses":false,"lengthMenu":[8,10,25,50,100]}},"evals":[],"jsHooks":[]}</script>


---

### 联立性检验：松露案例（联立性检验模型）

下面，我们继续进行豪斯曼联立性检验的**第二个步骤**（采用平狄克和鲁宾费尔德的建议），采用OLS方法估计如下**豪斯曼检验方程**和**平狄克检验方程**：

`$$\begin{align}
Q_i &amp;= \beta_0+\beta_1 \hat{P_i} +\beta_1 \hat{v}_{i1} +u_{i2} &amp;&amp;\text{(豪斯曼检验方程)} \\
Q_i &amp;= \beta_0+\beta_1P_i +\beta_1 \hat{v}_{i1} +u_{i2} &amp;&amp;\text{(平狄克检验方程)} 
\end{align}$$`

因此，我们马上可以得到**第二个步骤的检验结果**。

---

### 联立性检验：松露案例（豪斯曼检验；原始报告1）

如果采用**豪斯曼检验方程**，则有原始报告结果如下：


```

Call:
lm(formula = Hausman_models$mod.Q.Hausman, data = truffles_Hausman)

Residuals:
    Min      1Q  Median      3Q     Max 
-7.4756 -2.8917  0.2775  3.3937  5.3796 

Coefficients:
            Estimate Std. Error t value Pr(&gt;|t|)    
(Intercept) 11.94585    2.60369   4.588 9.21e-05 ***
hat.Pi       0.10383    0.04001   2.595  0.01510 *  
hat.vi       0.33801    0.11304   2.990  0.00589 ** 
---
Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1

Residual standard error: 3.803 on 27 degrees of freedom
Multiple R-squared:  0.3673,	Adjusted R-squared:  0.3205 
F-statistic: 7.838 on 2 and 27 DF,  p-value: 0.00207
```

---

### 联立性检验：松露案例（豪斯曼检验；精简报告1）

如果采用**豪斯曼检验方程**，上述精简报告结果如下：

`$$\begin{alignedat}{999}
&amp;\widehat{Q}=&amp;&amp;+11.95&amp;&amp;+0.10\hat{P}&amp;&amp;+0.34\hat{v}_{1}\\
&amp;\text{(t)}&amp;&amp;(4.5880)&amp;&amp;(2.5952)&amp;&amp;(2.9901)\\
&amp;\text{(se)}&amp;&amp;(2.6037)&amp;&amp;(0.0400)&amp;&amp;(0.1130)\\
&amp;\text{(fitness)}&amp;&amp; n=30;&amp;&amp; R^2=0.3673;&amp;&amp; \bar{R^2}=0.3205\\
&amp; &amp;&amp; F^{\ast}=7.84;&amp;&amp; p=0.0021\\
\end{alignedat}$$`

- 豪斯曼联立性检验的结论：
    
    - 
    `\(\hat{v}_{1i}\)`前的系数等于0.34，
    `\(t^{\ast}=2.9901&gt;t{(\alpha/2,n-3)}=\)`
    2.4726599。(给定
    `\(\alpha=0.01\)`
    )
    
    - 因此，
    `\(\hat{v}_{i1}\)`前系数的t检验是**极显著的**(给定
    `\(\alpha=0.01\)`
    水平下)，从而**拒绝原假设**
    `\(H_0\)`
    （无联立性问题），接受备择假设
    `\(H_1\)`
    ，认为**存在联立性问题**。

---

### 联立性检验：松露案例（平狄克检验；原始报告2）

如果采用**平狄克检验方程**，则R原始报告结果如下：


```

Call:
lm(formula = Hausman_models$mod.Q.Pindyck, data = truffles_Hausman)

Residuals:
    Min      1Q  Median      3Q     Max 
-7.4756 -2.8917  0.2775  3.3937  5.3796 

Coefficients:
            Estimate Std. Error t value Pr(&gt;|t|)    
(Intercept) 11.94585    2.60369   4.588 9.21e-05 ***
P            0.10383    0.04001   2.595   0.0151 *  
hat.vi       0.23418    0.11991   1.953   0.0613 .  
---
Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1

Residual standard error: 3.803 on 27 degrees of freedom
Multiple R-squared:  0.3673,	Adjusted R-squared:  0.3205 
F-statistic: 7.838 on 2 and 27 DF,  p-value: 0.00207
```


---

### 联立性检验：松露案例（平狄克检验；精简报告2）

如果采用**平狄克检验方程**，可以得到如下精简报告结果：

&lt;!---
fun_report_eq(Hausman_models$mod.Q.Pindyck,lm.dt =truffles_Hausman)
---&gt;

`$$\begin{alignedat}{999}
&amp;\widehat{Q}=&amp;&amp;+11.95&amp;&amp;+0.10P&amp;&amp;+0.23\hat{v}_{1}\\
&amp;\text{(t)}&amp;&amp;(4.5880)&amp;&amp;(2.5952)&amp;&amp;(1.9529)\\
&amp;\text{(se)}&amp;&amp;(2.6037)&amp;&amp;(0.0400)&amp;&amp;(0.1199)\\
&amp;\text{(fitness)}&amp;&amp; n=30;&amp;&amp; R^2=0.3673;&amp;&amp; \bar{R^2}=0.3205\\
&amp; &amp;&amp; F^{\ast}=7.84;&amp;&amp; p=0.0021\\
\end{alignedat}$$`

- 联立性问题检验结论：

    - 
    `\(\hat{v}_{i1}\)`前的系数等于0.23，
    `\(t^{\ast}=1.9529&gt;t{(\alpha/2,n-3)}=\)`
    1.7032884。(给定
    `\(\alpha=0.1\)`
    )
    
    - 因此，
    `\(\hat{v}_{1i}\)`前系数的t检验是**显著的**(给定
    `\(\alpha=0.1\)`
    水平下)，从而**拒绝原假设**
    `\(H_0\)`
    （无联立性问题），接受备择假设
    `\(H_1\)`
    ，认为**存在联立性问题**

---
layout: false
class: center, middle, duke-softblue,hide_logo
name: test-exogeneity

# 19.4 外生性检验

---
layout: true

&lt;div class="my-header-h2"&gt;&lt;/div&gt;
&lt;div class="watermark1"&gt;&lt;/div&gt;
&lt;div class="watermark2"&gt;&lt;/div&gt;
&lt;div class="watermark3"&gt;&lt;/div&gt;

&lt;div class="my-footer"&gt;&lt;span&gt;huhuaping@ 
&lt;a href="#chapter-navi"&gt;模块04 联立方程模型（SEM） |&lt;/a&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;
&lt;a href="#chapter19"&gt;第19章 联立方程模型的识别问题 |&lt;/a&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;
&lt;a href="#test-exogeneity"&gt; 19.4 外生性检验 |&lt;/a&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;
&lt;/span&gt;&lt;/div&gt; 

---

### 外生性检验

 略

---

### 要点与结论


1. 识别问题的考虑应先于估计问题。

2. 识别问题是问我们能否从约简系数估计值求出结构系的唯一数值估计值。

3. 如果能做到，就说联立方程组中的某个方程是可识别的；如果做不到，该方程就是不可识别或识別不足的。

4. 一个可识别的方程可以是恰好识别的或过度识别的。在前一种情形中，可以得到的唯一值；而在后一种情形中，可以得到不止一个估计值。

5. 识別问题之所以出现，是因为同样的数据集适合于不同的
的模型。



---

### 要点与结论


6. 要判断一个结构方程的可识别性，我们可以应用约简型方程的技术，把一个内生变量表达为前定变量的函数。

7. 这种耗时的程序由于**阶条件**或**秩条件**的利用而得以避免。阶条件虽然易用应用，但它仅是可识别性的**必要而非充分**条件；秩条件则是可识别性的**充分必要**条件。

8. 当出现联立性问题时，OLS一般而言是不适用的。但如果我们仍想用它，则必须明确地进行联立性检验，为此，可利用豪斯曼内生性检验方法。

9. 虽然在实践中一个变量是内生或外生的，是凭判断而决定的，但我们可以用豪斯曼设定检验判定一个或一组变量是内生的还是外生的。

10. 因果关系和外生性虽属于同一类问题，但它们的概念却是不同的。其中一个概念并不蕴含另一个概念。在实践中，仍然是把这两个概念区分开来为好。


---
layout:false
background-image: url("../pic/thank-you-gif-funny-little-yellow.gif")
class: inverse,center
# 本章结束

    </textarea>
<style data-target="print-only">@media screen {.remark-slide-container{display:block;}.remark-slide-scaler{box-shadow:none;}}</style>
<script src="https://remarkjs.com/downloads/remark-latest.min.js"></script>
<script>var slideshow = remark.create({
"highlightStyle": "github",
"highlightLines": true,
"countIncrementalSlides": false,
"ratio": "16:9"
});
if (window.HTMLWidgets) slideshow.on('afterShowSlide', function (slide) {
  window.dispatchEvent(new Event('resize'));
});
(function(d) {
  var s = d.createElement("style"), r = d.querySelector(".remark-slide-scaler");
  if (!r) return;
  s.type = "text/css"; s.innerHTML = "@page {size: " + r.style.width + " " + r.style.height +"; }";
  d.head.appendChild(s);
})(document);

(function(d) {
  var el = d.getElementsByClassName("remark-slides-area");
  if (!el) return;
  var slide, slides = slideshow.getSlides(), els = el[0].children;
  for (var i = 1; i < slides.length; i++) {
    slide = slides[i];
    if (slide.properties.continued === "true" || slide.properties.count === "false") {
      els[i - 1].className += ' has-continuation';
    }
  }
  var s = d.createElement("style");
  s.type = "text/css"; s.innerHTML = "@media print { .has-continuation { display: none; } }";
  d.head.appendChild(s);
})(document);
// delete the temporary CSS (for displaying all slides initially) when the user
// starts to view slides
(function() {
  var deleted = false;
  slideshow.on('beforeShowSlide', function(slide) {
    if (deleted) return;
    var sheets = document.styleSheets, node;
    for (var i = 0; i < sheets.length; i++) {
      node = sheets[i].ownerNode;
      if (node.dataset["target"] !== "print-only") continue;
      node.parentNode.removeChild(node);
    }
    deleted = true;
  });
})();
(function() {
  "use strict"
  // Replace <script> tags in slides area to make them executable
  var scripts = document.querySelectorAll(
    '.remark-slides-area .remark-slide-container script'
  );
  if (!scripts.length) return;
  for (var i = 0; i < scripts.length; i++) {
    var s = document.createElement('script');
    var code = document.createTextNode(scripts[i].textContent);
    s.appendChild(code);
    var scriptAttrs = scripts[i].attributes;
    for (var j = 0; j < scriptAttrs.length; j++) {
      s.setAttribute(scriptAttrs[j].name, scriptAttrs[j].value);
    }
    scripts[i].parentElement.replaceChild(s, scripts[i]);
  }
})();
(function() {
  var links = document.getElementsByTagName('a');
  for (var i = 0; i < links.length; i++) {
    if (/^(https?:)?\/\//.test(links[i].getAttribute('href'))) {
      links[i].target = '_blank';
    }
  }
})();
// adds .remark-code-has-line-highlighted class to <pre> parent elements
// of code chunks containing highlighted lines with class .remark-code-line-highlighted
(function(d) {
  const hlines = d.querySelectorAll('.remark-code-line-highlighted');
  const preParents = [];
  const findPreParent = function(line, p = 0) {
    if (p > 1) return null; // traverse up no further than grandparent
    const el = line.parentElement;
    return el.tagName === "PRE" ? el : findPreParent(el, ++p);
  };

  for (let line of hlines) {
    let pre = findPreParent(line);
    if (pre && !preParents.includes(pre)) preParents.push(pre);
  }
  preParents.forEach(p => p.classList.add("remark-code-has-line-highlighted"));
})(document);</script>

<script>
slideshow._releaseMath = function(el) {
  var i, text, code, codes = el.getElementsByTagName('code');
  for (i = 0; i < codes.length;) {
    code = codes[i];
    if (code.parentNode.tagName !== 'PRE' && code.childElementCount === 0) {
      text = code.textContent;
      if (/^\\\((.|\s)+\\\)$/.test(text) || /^\\\[(.|\s)+\\\]$/.test(text) ||
          /^\$\$(.|\s)+\$\$$/.test(text) ||
          /^\\begin\{([^}]+)\}(.|\s)+\\end\{[^}]+\}$/.test(text)) {
        code.outerHTML = code.innerHTML;  // remove <code></code>
        continue;
      }
    }
    i++;
  }
};
slideshow._releaseMath(document);
</script>
<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
(function () {
  var script = document.createElement('script');
  script.type = 'text/javascript';
  script.src  = 'https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-MML-AM_CHTML';
  if (location.protocol !== 'file:' && /^https?:/.test(script.src))
    script.src  = script.src.replace(/^https?:/, '');
  document.getElementsByTagName('head')[0].appendChild(script);
})();
</script>
  </body>
</html>
